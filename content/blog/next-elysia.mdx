---
title: Next.js + Elysia Started
description: Create a full-stack application with Next.js and ElysiaJS
image: https://github.com/tiesen243/tiesen243/assets/101703006/572022b4-a286-4669-a0ca-7a3e32e3a1a1
date: 2024-04-07
tags:
  - nextjs
  - elysiajs
  - prisma
  - tailwindcss
  - swr
---

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Backend](#backend)
4. [Fontend](#fontend)
5. [Reference](#reference)

## Introduction

Hello everynyan!
Today, we're diving into the world of full-stack web development using Next.js and Elysia.js, two powerful frameworks that streamline frontend and backend development, respectively.

## Installation

```bash title="Create a new project"
bun create next-app --example https://github.com/tiesen243/next-elysia [your-app-name]
cd [your-app-name]
```

Next step, update your enviroment variables
> If you want to add other variables, remember to add it to `env.mjs` to validate it

```bash title=".env"
DATABASE_URL=""
```

> In this project, i'm use MongoDb for Database, if you use other database, remember to change provider in `prisma/schema.prisma` and change Id fields

Then, push schema to your database

```bash title="Push schema to database"
bun run db:format
bun run db:migrate
bun run db:push
```

Finaly, run your development server

```bash title="Run development server"
bun dev
```

## Backend

Make your route model at `server/models/*.ts` and import to your route

Define your route at `server/routes/*.ts` and update this route to `server/elysia.ts`

> Note: in this example, i'm use `post` as a model name for example

```ts title="server/models/post.model.ts"
import { Elysia } from 'elysia'

export const PostModel = new Elysia({ name: 'Model.Post' }).model({
  hello: t.Object({ content: t.String({ minLength: 4 }) }),
})
```

Create your new route

```ts title="server/routes/post.route.ts"
import { Elysia } from 'elysia'

import { authMiddleware } from '@/server/auth'
import { PostModel } from '@/server/models/post.model'
import { db } from '@/prisma'

export const PostRoute = new Elysia({ prefix: '/[abc]' })
  .use(PostModel)

  // public routes

  .get('/all', async ({ error }) => {
    const posts = await db.post.findMany({
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        content: true,
        author: { select: { id: true, name: true } },
      },
    })
    if (!posts || posts.length === 0) return error(404, { message: 'No posts found' })
    return posts
  })

 

  // protected routes
  .use(authMiddleware)

  .post(
    '/create',
    async ({ user, body: { content }, error }) => {
      const post = await db.post.create({
        data: { content, author: { connect: { id: user?.id } } },
      })
      if (!post) return error(500, { message: 'Failed to create post' })
      return { message: 'Post created successfully' }
    },
    { body: 'CreatePost' },
  )

  .delete('/del/:id', async ({ params: { id }, user, error }) => {
    const post = await db.post.findUnique({ where: { id } })
    if (!post) return error(404, { message: 'Post not found' })

    if (post.authorId !== user?.id)
      return error(403, { message: 'You are not authorized to delete this post' })

    await db.post.delete({ where: { id } })
    return { message: 'Post deleted successfully' }
  })
```

Add this route to app 

```ts title="server/elysia.ts"
import { Elysia } from 'elysia'

import { PostRoute } from '@/server/routes/post.route'

export const app = new Elysia({ prefix: '/api/elysia' })
  /* others config */
  .use(PostRoute)
```

## Fontend

Now, use your api endpoint with `swr` and `@elysiajs/eden` for example:

> In this example, i'm use `api.post` for post route

Create hook for post to get all post, create post and delete post

```ts title="lib/hooks/post.ts"
import useSWR from 'swr'
import useSWRMutation from 'swr/mutation'

import { api } from '@/lib/api'

export const usePost = () => {
  const {
    data: posts,
    error: getError,
    isLoading,
    mutate,
  } = useSWR('posts', () =>
    api.post.all.get().then(({ error, data }) => (error ? Promise.reject(error.value) : data)),
  )

  const {
    trigger: create,
    isMutating,
    error: createError,
  } = useSWRMutation<unknown, Error, string, { content: string }>('posts', (_, { arg }) =>
    api.post.create.post(arg).then(({ data, error }) => {
      if (error) throw error.value
      mutate()
      return data
    }),
  )

  const { trigger: del } = useSWRMutation<unknown, Error, string, string>('posts', (_, { arg }) =>
    api.post
      .del({ id: arg })
      .delete()
      .then(() => mutate()),
  )

  return {
    posts,
    getError,
    isLoading,
    mutate,

    create,
    isMutating,
    createError,

    del,
  }
}

```

Then, use it in your app

```tsx title="components/post-list.tsx"
'use client'

import { Loader2Icon, XIcon } from 'lucide-react'

import { Card, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { usePost } from '@/lib/hooks'
import { Button } from '@/components/ui/button'

export const PostList: React.FC<{ userId?: string }> = ({ userId }) => {
  const { posts, isLoading, getError, del } = usePost()

  if (isLoading) return <Loader2Icon className="mx-auto animate-spin" />
  if (getError || !posts)
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return <p className="text-center text-destructive">Error: {getError?.message}</p>

  return (
    <section className="mx-auto mb-4 max-w-screen-md space-y-4">
      {posts.map((post) => (
        <Card key={post.id}>
          {post.author.id === userId && (
            <Button
              onClick={() => del(post.id)}
              className="absolute right-2 top-2 z-10"
              variant="ghost"
              size="icon"
            >
              <XIcon />
            </Button>
          )}
          <CardHeader>
            <CardDescription>{post.author.name}</CardDescription>
            <CardTitle>{post.content}</CardTitle>
          </CardHeader>
        </Card>
      ))}
    </section>
  )
}
```

Create a form to create post 

```tsx title="components/create-post.tsx"
'use client'

import { useRef } from 'react'
import { SendHorizonalIcon } from 'lucide-react'

import { Card, CardFooter, CardHeader } from '@/components/ui/card'
import { FormField } from '@/components/ui/form-field'
import { usePost } from '@/lib/hooks'
import { Button } from '@/components/ui/button'

export const CreatePost: React.FC = () => {
  const { create: trigger, isMutating, createError } = usePost()
  const formRef = useRef<HTMLFormElement>(null)

  return (
    <Card className="mx-auto mb-4 max-w-screen-md">
      <form
        ref={formRef}
        action={(fd: FormData) => {
          trigger({ content: String(fd.get('content')) })
          formRef.current?.reset()
        }}
      >
        <CardHeader className="flex-row items-center gap-2 space-y-0">
          <FormField name="content" placeholder="What are you thinking?" className="flex-grow" />
          <Button variant="ghost" size="icon" isLoading={isMutating}>
            <SendHorizonalIcon />
          </Button>
        </CardHeader>
        <CardFooter>
          {createError && (
            <p className="text-destructive">Error: {createError?.fieldsError?.content}</p>
          )}
        </CardFooter>
      </form>
    </Card>
  )
}
```

And, use it in your page

```tsx title="app/page.tsx"
import type { NextPage } from 'next'

import { auth } from '@/server/auth'
import { PostList } from '@/components/post-list'
import { CreatePost } from '@/components/create-post'

const Page: NextPage = async () => {
  const { user } = await auth()

  return (
    <main className="container">
      <PostList userId={user.id} />
      <CreatePost />
    </main>
  )
}
```

### Notes

1. `trigger` function form `swr/mutation` will make `isMutating` state always `false` if you use it in `async` function or `promise` function, so you should use it in normal function 

```ts 
const action = () => trigger() // not work 

const action = async () => {
  await trigger() // not work
} 

const action = () => {
  trigger() // work
}
```

2. If you want to use `api` in your server side, and you want to use `auth` function, you should pass `headers()` to options in your api call. This is the example:

```ts title="app/server/page.tsx"
import type { NextPage } from 'next'

import { api } from '@/lib/api'
import { headers } from 'next/headers'

const Page: NextPage = async () => {
  const { data, error } = await api.post.create.post(
    { content: 'hello' },
    { headers: headers() as unknown as Record<string, string> },
  )
  console.log({ data, error })
  return <div>Page</div>
}

export default Page
```

3. If you want to use middleware, you must use Prisma Accelerate to make it work because Prisma can't run in Edge Serverless. This is the example:

```ts title="middleware.ts"
import { NextRequest, NextResponse } from 'next/server'

import { validateCookie } from '@/server/auth'

export const middleware = async (req: NextRequest) => {
  const cookie = req.cookies.get('auth_session')
  const { user } = await validateCookie(`${cookie?.name}=${cookie?.value}`)
  if (!user) return NextResponse.redirect(new URL('/auth/login', req.url))
}

export const config = {
  matcher: ['/middleware'],
}
```

## Reference

### Documents

- Next.js: [nextjs.org](https://nextjs.org/)
- ElysiaJS: [elysiajs.com](https://elysiajs.com/)
- SWR: [swr.vercel.app](https://swr.vercel.app/)

### Try it now!!!

1. Fork my repository: [here](https://github.com/tiesen243/next-elysia/)
2. Demo web app: [here](https://next-elysia.vercel.app/)

<div align="center">
  <b>Thanks for reading, hope you like this</b>
</div>
